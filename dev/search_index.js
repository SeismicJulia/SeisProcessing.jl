var documenterSearchIndex = {"docs":
[{"location":"lib/public/#Public-documentattion-1","page":"Public","title":"Public documentattion","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Documentation for public SeisProcessin.jl public interface","category":"page"},{"location":"lib/public/#Public-interface-1","page":"Public","title":"Public interface","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"SeisAddNoise\nSeisLinearEvents\nSeisParabEvents\nSeisHypEvents\nSeisKolmogoroff\nMeasureSNR\nSeisBandPass\nSeisDecimate\nSeisDelay\nSeisDiff\nSeisEnvelope\nSeisFKFilter\nSeisGain\nSeisMute\nSeisNMO\nSeisPWD\nSeisProcessFile\nSeisRadonFreqFor\nSeisRadonFreqInv\nSeisSincInterp1D","category":"page"},{"location":"lib/public/#SeisProcessing.SeisAddNoise","page":"Public","title":"SeisProcessing.SeisAddNoise","text":"SeisAddNoise(d, snr; <keyword arguments>)\n\nAdd noise to an N-dimensional input data d. Should specify the signal-to-noise ratio level snr. Noise can be band limited using kewyord L.\n\nArguments\n\nd::Array{Real, N}: N-dimensional data.\nsnr::Real: signal-to-noise ratio.\ndb::Bool=false: Flag is false if snr is given by amplitude. Flag is true if\n\nsnr is given in dB.\n\npdf::AbstractString=\"gaussian\": random noise probability distribution:\n\n\"gaussian\" or \"uniform\".\n\nL::Int=1: averaging operator length to band-limit the random noise.\n\nExamples\n\njulia> using PyPlot\njulia> w = Ricker(); wn = SeisAddNoise(w, 2); plot(w); plot(wn);\nMeasureSNR(w, wn)\njulia> d = SeisHypEvents(); dn = SeisAddNoise(d, 1.0, db=true, L=9);\nSeisPlotTX([d dn]); MeasureSNR(d, dn, db=true)\n\nCredits: Juan I. Sabbione, 2016\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisLinearEvents","page":"Public","title":"SeisProcessing.SeisLinearEvents","text":"SeisLinearEvents(; <keyword arguments>)\n\nGenerate up to five dimensional data consisting of linear events.\n\nArguments\n\not=0.0: first sample for the time axis in secs.\ndt=0.004: time sampling interval in secs.\nnt=500: number of time samples.\nox1=0.0: first sample for the first spatial dimension in meters.\ndx1=10.0: sample interval for the first spatial dimension in meters.\nnx1=100: number of samples for the first spatial dimension.\nox2=0.0: first sample for the second spatial dimension in meters.\ndx2=10.0: sample interval for the second spatial dimension in meters.\nnx2=1: number of samples for the second spatial dimension.\nox3=0.0: second sample for the third spatial dimension in meters.\ndx3=10.0: sample interval for the third spatial dimension in meters.\nnx3=1: number of samples for the third spatial dimension.\nox4=0.0: third sample for the fourth spatial dimension in meters.\ndx4=10.0: sample interval for the fourth spatial dimension in meters.\nnx4=1:number of samples for the fourth spatial dimension.\ntau=[1.0, 1.5]: intercept traveltimes for each event.\np1=[0.0001,-0.0003]: Dip of events on the first dimension\np2,p3,p4=[0, 0]: Dip of events on the following dimensions\namp=[1.0,-1.0]: amplitudes for each linear event.\nf0=20.0: central frequency of wavelet for each linear event.\n\nExample\n\njulia> using SeisPlot\njulia> d = SeisLinearEvents(); SeisPlotTX(d);\n\nCredits: Aaron Stanton, 2015\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisParabEvents","page":"Public","title":"SeisProcessing.SeisParabEvents","text":"SeisParabEvents(; <keyword arguments>)\n\nGenerate up to five dimensional data consisting of parabolic events.\n\nArguments\n\not=0.0: first sample for the time axis in secs.\ndt=0.004: time sampling interval in secs.\nnt=500: number of time samples.\nox1=0.0: first sample for the first spatial dimension in meters.\ndx1=10.0: sample interval for the first spatial dimension in meters.\nnx1=100: number of samples for the first spatial dimension.\nox2=0.0: first sample for the second spatial dimension in meters.\ndx2=10.0: sample interval for the second spatial dimension in meters.\nnx2=1: number of samples for the second spatial dimension.\nox3=0.0: second sample for the third spatial dimension in meters.\ndx3=10.0: sample interval for the third spatial dimension in meters.\nnx3=1: number of samples for the third spatial dimension.\nox4=0.0: third sample for the fourth spatial dimension in meters.\ndx4=10.0: sample interval for the fourth spatial dimension in meters.\nnx4=1:number of samples for the fourth spatial dimension.\ntau=[1.0, 1.6]: intercept traveltimes for each event.\n`p1=[0.0000,-0.0001]\n`p2=[0.0003, 0.0002]\n`p3=[-0.0001,-0.0001]\n`p4=[0.0001,-0.0000]\namp=[1.0,-1.0]: amplitudes for each parabolic event.\nwavelet=\"ricker\": wavelet used to model the parabolicr events.\nf0=[20.0]: central frequency of wavelet for each parabolic event.\n\nExample\n\njulia> using SeisPlot\njulia> d = SeisParabEvents(); SeisPlotTX(d);\n\nCredits: Mauricio D Sacchi, 2015\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisHypEvents","page":"Public","title":"SeisProcessing.SeisHypEvents","text":"SeisHypEvents(; <keyword arguments>)\n\nGenerate two dimensional data consisting of hyperbolic events.\n\nArguments\n\not::Real=0.0: first sample for the time axis in secs.\ndt::Real=0.004: time sampling interval in secs.\nnt::Int=301: number of time samples.\nox::Real=-1000.0: first sample for spatial dimension in meters.\ndx::Real=20.0: sample interval for the spatial dimension in meters.\nnx::Int=101: number of samples for the spatial dimension.\ntau::Vector{Real}=[0.2, 0.6, 0.9]: intercept traveltimes for each event.\nvel::Vector{Real}=[1500.0, 2000.0, 3000.0]: rms velocities in m/s\napex::Vector{Real}=[0.0, 0.0, 0.0]: apex-shifts in meters.\namp::Vector{Real}=[1.0, -1.0, 1.0]: amplitudes for each event.\nwavelet::AbstractString=\"ricker\": wavelet used to model the events.\nf0::Vector{Real}=[20.0]: central frequency of wavelet for each event.\n\nOutput\n\nd::Array{Real, 2}: two dimensional data consisting of hyperbolic events.\n\nExamples\n\njulia> using SeisPlot\njulia> d = SeisHypEvents(); SeisPlotTX(d);\njulia> d = SeisHypEvents(apex=[100, 200, -300], f0=[30, 20, 15]);\nSeisPlotTX(d);\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisKolmogoroff","page":"Public","title":"SeisProcessing.SeisKolmogoroff","text":"SeisKolmogoroff(in)\n\nTransform a wavelet into its minimum phase equivalent.\n\nArguments\n\nin::Array{Real,1}: input wavelet.\n\nExample\n\njulia> using PyPlot\njulia> w = Ricker()\njulia> wmin = SeisKolmogoroff(w)\njulia> plot(w); plot(wmin)\n\nReference\n\nClaerbout, Jon F., 1976, Fundamentals of geophysical data processing.\n\nMcGraw-Hill Inc.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.MeasureSNR","page":"Public","title":"SeisProcessing.MeasureSNR","text":"MeasureSNR(signal, noisy; db=false)\n\nMeasure the signal-to-noise ratio between the clean input signal and the contaminated input noisy.\n\nArguments\n\nsignal::Array{Real, N}: N-dimensional clean signal. N must be <= 5.\nnoisy::Array{Real, N}: N-dimensional noisy signal of same size as signal.\ndb::Bool=false: Flag is false if the signal-to-noise ratio is measured by amplitude. Flag is true if snr is in dB.\n\nExample\n\njulia> d = SeisHypEvents(); dnoisy = SeisAddNoise(d, 2);\nMeasureSNR(d, dnoisy)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisBandPass","page":"Public","title":"SeisProcessing.SeisBandPass","text":"SeisBandPass(in; <keyword arguments>)\n\nApply a bandpass filter to seismic data. Input and output data is 2D in tx domain. Filter is applied in fx domain.\n\nArguments\n\nin: Input 2D data array in tx domain. Time is first dimension.\n\nKeyword arguments\n\ndt=0.004: time sampling interval in secs.\nfa=0: lower frequency cut [Hz]\nfb=0: lower frequency banpass [Hz]\nfc=60: upper frequency bandpass [Hz]\nfd=80: upper frequency cut [Hz]\n\nExample\n\njulia> d = SeisLinearEvents(); SeisPlotAmplitude(d,125,0.004);\njulia> d_filter = SeisBandPass(d;dt=0.004,fa=2,fb=8,fc=12,fd=20); SeisPlotAmplitude(d_filter,125,0.004)\njulia> SeisPlot([d d_filter],title=\"Data and Filtered data\")\n\n\n\n\n\n\nSeisBandPass(in,out,parameters; <keyword arguments>)\n\nArguments\n\nin::String: Input file - Seis format\nout::String: Output file - Seis format.\nparameters : list of the keyword arguments for the function SeisBandPass.\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial trace number\nntrace=10000 : Total number of traces to process at once\n\nExample\n\njulia> param = Dict(:fa>=0,:fb=>0,:fc=>60,:fd=>80)\njulia> SeisBandPass(filein,fileout, param,group=\"all\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisDecimate","page":"Public","title":"SeisProcessing.SeisDecimate","text":"SeisDecimate(in; <keyword arguments>)\n\nApply random or regular decimation to a multidimensional array of data. Input and output have the same dimensions.\n\nArguments\n\nin: input data as 2D, or 3D,4D,5D tensors. The first dimension is time.\n\nKeyword arguments\n\nmode=\"random\": decimation mode. Random is default, else decimates uniformly.\nperc=50: percentage of traces equal to zero (decimated). Only for random mode\nincx1=1: consecutive traces zeroed in first dimension. Only for regular decimation\nincx2=1: consecutive traces zeroed in second dimension.\nincx3=1: consecutive traces zeroed in third dimension.\nincx4=1: consecutive traces zeroed in fourth dimension.\n\nExample\n\njulia> d = SeisLinearEvents(); deci = SeisDecimate(d);\n\nCredits: Aaron Stanton,2017\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisDelay","page":"Public","title":"SeisProcessing.SeisDelay","text":"SeisDelay(in; <keyword arguments>)\n\nApply a time delay to 2D data\n\nArguments\n\nin: input 2D data array in tx domain. First dimension is time.\n\nKeyword arguments\n\ndelay=0.1: desired time delay in secs.\ndt=0.004: time sampling interval in secs.\n\nExample\n\njulia> d = SeisLinearEvents(); deli = SeisDelay(d);\n\nCredits: Aaron Stanton,2017\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisDiff","page":"Public","title":"SeisProcessing.SeisDiff","text":"SeisDiff(d ; <keyword arguments>)\n\nApply differentiation to seismic traces in freq. It can also be used to apply a phase rotation\n\nArguments\n\nd: Input 2D data array in tx domain. First dimension is time.\n\nKeyword arguments\n\ndelay=0.1: desired time delay in seconds.\npow=-2: order of derivative\nrot=0: constant phase shift or rotation\n\nExample\n\njulia> d = SeisLinearEvents(); SeisPlotTX(d);\njulia> d2 = SeisDiff(d;dt=0.004,pow=1); SeisPlotTX(d);\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisEnvelope","page":"Public","title":"SeisProcessing.SeisEnvelope","text":"SeisEnvelope(in; <keyword arguments>)\n\nCalculate the envelope attribute of a group of input traces.\n\nArguments\n\nin: input data. A 2D Array where the first dimension is time.\n\nExample\n\njulia> using PyPlot\njulia> dtsec = 0.002; w = Ricker(dt=dtsec);\njulia> e = SeisEnvelope(w); t=dtsec*collect(0:1:length(w)-1);plot(t,w,t,e,\"-r\");xlabel(\"Time [s]\")\n\nCredits: Aaron Stanton,2017\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisFKFilter","page":"Public","title":"SeisProcessing.SeisFKFilter","text":"SeisFKFilter(in; <keyword arguments>)\n\nRemoves energy from seismic data by applying filters to a gather in the Frequency-wavenumber domain\n\nArguments\n\nin: 2D input data in TX domain. First dimension is time.\n\nKeyword arguments\n\ndt=0.004: time sampling interval in secs.\ndx=10: space sampling interval in meters.\nva=-2000,vb=-3000,vc=3000,vd=2000: apparent velocity corners to filter\n\nOutput\n\nout: Filtered data in TX domain\n\nExample\n\njulia> d = SeisLinearEvents(); df = SeisFKFilter(d,va=-4000.,vb=-6000.,vc=6000.,vd=4000.);\n\nCredits: Aaron Stanton,2017\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisGain","page":"Public","title":"SeisProcessing.SeisGain","text":"SeisGain(d ; <keyword arguments>)\n\nGain a group of traces. Input and output are 2D.\n\nArguments\n\nd::Array{Real,2}: two dimensional data.\n\nKeyword arguments\n\ndt::Real=0.004: sampling interval in secs.\nkind::AbstractString=\"time\": if kind=\"time\", gain = t.^a . * exp(-bt);                        if kind=\"agc\", automatic gain control is applied.\ncoef::Vector{Real}=[2.0,0.0]: if kind=\"time\", coef = [a,b];                                  if kind=\"agc\", coef = [agc_gate]\nnormal::Int=0: normal=0 no normalization; normal=1 normalize each trace by                 amplitude; normal=2 normalize each trace by rms value/\n\nExample\n\njulia> using PyPlot\njulia> d = SeisHypEvents();\n       dout = SeisGain(d, kind=\"agc\", coef=[0.05]);\n       SeisPlotTX([d dout]);\n\nCredits:  Aaron Staton Updates: Juan I. Sabbione, Mauricio D. Sacchi, Fernanda Carozzi\n\n\n\n\n\nSeisGain(in,out,parameters; <keyword arguments>)\n\nGain a group of traces. Input and output are file names.\n\nArguments\n\nin::String: Input file - Seis format\nout::String: Output file - Seis format.\nparameters : list of the keyword arguments for the function SeisGain.\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial trace number\nntrace=10000 : Total number of traces to process at once\n\nExample\n\njulia> param = Dict(:dt=>0.01,:kind=>\"time\",:coef=>[2.0,0.0],:normal=>0)\njulia> SeisGain(filein,fileout, param,group=\"all\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisMute","page":"Public","title":"SeisProcessing.SeisMute","text":"SeisMute(d; <keyword arguments>) -> Array{Real,2}\n\nMute trace noise before the first arrival. The muting function depends on the offset between source and receiver and the velocity of the first layer as tmute = t0 + offset/v1.\n\nArguments\n\nd: Array of input traces.\n\nKeyword arguments\n\noffset=[0.]: Vector of distances between source and receiver.\ntmute=0.: initial muting time\nvmute=1500.: Velocity of the first layer.\ntaper=0.1: Taper of the muting function\ndt::Real=0.004: sampling interval in secs.\n\n\n\n\n\nSeisMute(in,out,parameters; <keyword arguments>)\n\nMutes noise before first arrival of traces in a file. Saves the muted traces to an output file. The muting function depends on the offset between source and receiver and the velocity of the first layer as tmute = t0 + offset/v1.\n\nArguments\n\nin::String: Input file - Seis format.\nout::String: Output file - Seis format.\nparameters : list of the keyword arguments for the function SeisMute.\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial trace number\nntrace=10000 : Total number of traces to process at once\n\nExample\n\njulia> param = Dict(:tmute=>0.0, :vmute=>10000, :taper=>0.05,:dt=>0.01)\njulia> SeisMute(filein,fileout, param,group=\"some\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisNMO","page":"Public","title":"SeisProcessing.SeisNMO","text":"SeisNMO(in,out,parameters; <keyword arguments>)\n\nArguments\n\nin::String: Input file - Seis format.\nout::String: Output file - Seis format.\nparameters : list of the keyword arguments for the function SeisMute.\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial trace number\nntrace=10000 : Total number of traces to process at once\n\nExample\n\njulia> param = Dict(:tmute=>0.0, :vmute=>10000, :taper=>0.05,:dt=>0.01)\njulia> SeisMute(filein,fileout, param,group=\"some\")\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisPWD","page":"Public","title":"SeisProcessing.SeisPWD","text":"SeisPWD(in;<keyword arguments>)\n\nDip estimation by Plane Wave Destruction. see http://sepwww.stanford.edu/data/media/public/sep//prof/pvi.pdf Chapter 4.\n\nArguments\n\n-w1=10 -w2=10 -dz_in=1 -dx_in=1 -format=\"angle\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisProcessFile","page":"Public","title":"SeisProcessing.SeisProcessFile","text":"  SeisProcessFile(in,out,operators,parameters;<keyword arguments>)\n\nRun processing flows that read and write from disk\n\nf is a function that has the following syntax: d2 = f(d1,param), where param is list of keyword arguments for the function. Note that f can be a vector of functions. They will be executed sequentially on the same group of traces.\n\nArguments\n\nin: input filename of type String or Array{String,1} - Seis format\nout: output filenames of type String or Array{String,1} - Seis format\noperators\nparameters\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial traces\nntrace=10000 : Total number of traces to process at once\n\nExample\n\nApply a bandpass filter to a seismic cube sequentially, by shot gather. Assume dt is equal to 0.002.\n\njulia> operators = [SeisBandPass]\njulia> param = [Dict(:dt=>0.002, :fa=>20,:fb=>30,:fc=>80,:fd=>90)]\njulia> SeisProcessFile(filein,fileout,operators,param,key=[\"sx\"])\n\n\n\n\n\n  SeisProcessFile(in1,in2,out,operators,parameters;<keyword arguments>)\n\nRun processing flows that read from 2 files and write to disk\n\nArguments\n\nin1::String: input filename - Seis format.\nin2::String: input filename - Seis format.\nout::String: output filename - Seis format.\noperators\nparameters\n\nKeyword arguments\n\ngroup=\"gather\" : Options are all, some or gather\nkey=[\"imx\",\"imy\"] : Defines type of gather\nitrace=1 : Initial traces\nntrace=10000 : Total number of traces to process at once\n\nExample\n\nApply a bandpass filter to a seismic cube sequentially, by shot gather. Assume dt is equal to 0.002.\n\njulia> operators = [SeisBandPass]\njulia> param = [Dict(:dt=>0.002, :fa=>20,:fb=>30,:fc=>80,:fd=>90)]\njulia> SeisProcessFile(filein,fileout,operators,param,key=[\"sx\"])\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisRadonFreqFor","page":"Public","title":"SeisProcessing.SeisRadonFreqFor","text":"SeisRadonFreqFor(in, nt; <keyword arguments>)\n\nTransform a tau-p gather to a time-offset gather using a frequency domain forward parabolic or linear Radon operator.\n\nArguments\n\nin::Array{Float64,2}: 2D Radon panel, in[1:ntau,1:np], where ntau is the\n\nnumber of intercept times and np the number of curvatures or ray parameters.\n\nnt::Int: number of time samples.\n\nKeyword arguments\n\norder=\"parab\": \"parab\" for parabolic transform, \"linear\"\n\nfor linear transform.\n\ndt=0.004: time sampling interval in seconds.\nh=collect(0.0:20.0:1000.0): offset vector; h[1:nh].\nhref=0.0: reference offset for parabolic Radon Transform. If the\n\ndefautl value href=0.0 is given, href is set to max(abs(h)).\n\np=collect(-0.05:0.01:2.2): p[1:np]. If order=\"parab\", p\n\nis a vector of residual moveout (\"curvatures\") at reference offset href in seconds; if order=linear, p is a vector of ray parameters in s/m.\n\nflow=0.0: minimum frequency in the data in Hz.\nfhigh=125.0: maximum frequency in the data in Hz.\n\nOutput\n\nd: data synthetized via forward Radon modeling, d[1:nt, 1:nh].\n\nReferences\n\nHampson, D., 1986, Inverse velocity stacking for multiple elimination:\n\nCanadian Journal of Exploration Geophysics, 22, 44-55.\n\nSacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and\n\noffset space reconstruction: Geophysics, 60, 1169-1177.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisRadonFreqInv","page":"Public","title":"SeisProcessing.SeisRadonFreqInv","text":"SeisRadonFreqInv(d; <keyword arguments>)\n\nTransform a Gather from time-offset gather to tau-p gather using a frequency domain inverse parabolic or linear Radon operator via least-squares inversion.\n\nArguments\n\nd::Array{Float64,2}: 2D data, d[1:nt,1:nh], where nt is number of\n\ntime samples and nh the number of receivers.\n\nKeyword arguments\n\norder::\"parab\": \"parab\" for parabolic transform, \"linear\"\n\nfor linear transform.\n\ndt=0.004: sampling interval in seconds.\nh=collect(0.0:20.0:1000.0): offset vector h[1:nh].\nhref=0.0: reference offset for parabolic Radon Transform. If the\n\ndefautl value href=0.0 is given, href is set to max(abs(h)).\n\np=collect(-0.05:0.01:2.2): p[1:np]. If order=\"parab\", p\n\nis a vector of residual moveout (\"curvatures\") at reference offset href in seconds; if order=linear, p is a vector of ray parameters in s/m.\n\nflow=0.0: minimum frequency in the data in Hz.\nfhigh=125.0: maximum frequency in the data in Hz.\nmu=0.001: trade off parameter or damping for the L.S. inversion.\n\nOutput\n\nm: inverted Radon panel m[1:ntau, 1:np].\n\nReferences\n\nHampson, D., 1986, Inverse velocity stacking for multiple elimination:\n\nCanadian Journal of Exploration Geophysics, 22, 44-55.\n\nSacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and\n\noffset space reconstruction: Geophysics, 60, 1169-1177.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SeisProcessing.SeisSincInterp1D","page":"Public","title":"SeisProcessing.SeisSincInterp1D","text":"SeisSincInterp1D(d,order)\n\nResample seismic traces via 1D sinc interpolation. The time series are sampled every dt secs,  the output corresponds to series with time interval dt/order.\n\nArguments\n\nd::Array{Real,N}: N-dimensional data, first dimension is time\norder::Integer: order of interpolation 2,4\n\nExamples\n\n2-time upsampling of a wavelet\n\njulia> order = 2; dt=0.004; w = Ricker(dt=dt, f0=20); t = collect(0:1:length(w)-1)*dt;\njulia> wout = SeisSincInterp1D(w,order); tout = collect(0:1:length(wout)-1)*dt/order;\njulia> plot(t,w); plot(tout,wout,\"*\")\n\n4-time upsampling of a gather\n\njulia> d = SeisLinearEvents(); di = SeisSincInterp1D(d,4);\njulia>  SeisPlotTX(d,style=\"wiggles\")\njulia>  SeisPlotTX(di,style=\"wiggles\")  \n\nMAY 2018, MDS\n\n\n\n\n\n","category":"function"},{"location":"#SeisProcessing.jl-1","page":"Home","title":"SeisProcessing.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Processing tools for the SeismicJulia project","category":"page"},{"location":"#Package-features-1","page":"Home","title":"Package features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Model multidimensional seismic volumes\nFilter seismic data including bandpass filter, FKfilter, FXDecon\nProcess field data via mutes, NMO correction, statics correction, stacking\nUse signal processing techniques as measure SNR, smooth 1D and 2D time series, 1D sinc interpolation","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SeisProcessing, from the SeismicJulia project, can be installed using Julia package manager.  From the Julia REPL, type ] to enter the Pkg REPL mode and run ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pkg> add SeisProcessing","category":"page"}]
}
