<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · SeisProcessing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SeisProcessing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href>Public</a><ul class="internal"><li><a class="toctext" href="#Public-interface-1">Public interface</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Public</a></li></ul><a class="edit-page" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/master/docs/src/lib/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-documentattion-1" href="#Public-documentattion-1">Public documentattion</a></h1><p>Documentation for public <code>SeisProcessin.jl</code> public interface</p><h2><a class="nav-anchor" id="Public-interface-1" href="#Public-interface-1">Public interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisAddNoise" href="#SeisProcessing.SeisAddNoise"><code>SeisProcessing.SeisAddNoise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisAddNoise(d, snr; &lt;keyword arguments&gt;)</code></pre><p>Add noise to an N-dimensional input data <code>d</code>. Should specify the signal-to-noise ratio level <code>snr</code>. Noise can be band limited using kewyord <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Array{Real, N}</code>: N-dimensional data.</li><li><code>snr::Real</code>: signal-to-noise ratio.</li><li><code>db::Bool=false</code>: Flag is false if snr is given by amplitude. Flag is true if</li></ul><p>snr is given in dB.</p><ul><li><code>pdf::AbstractString=&quot;gaussian&quot;</code>: random noise probability distribution:</li></ul><p><code>&quot;gaussian&quot;</code> or <code>&quot;uniform&quot;</code>.</p><ul><li><code>L::Int=1</code>: averaging operator length to band-limit the random noise.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using PyPlot
julia&gt; w = Ricker(); wn = SeisAddNoise(w, 2); plot(w); plot(wn);
MeasureSNR(w, wn)
julia&gt; d = SeisHypEvents(); dn = SeisAddNoise(d, 1.0, db=true, L=9);
SeisPlotTX([d dn]); MeasureSNR(d, dn, db=true)</code></pre><p>Credits: Juan I. Sabbione, 2016</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Modelling/SeisAddNoise.jl#L1-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisLinearEvents" href="#SeisProcessing.SeisLinearEvents"><code>SeisProcessing.SeisLinearEvents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisLinearEvents(; &lt;keyword arguments&gt;)</code></pre><p>Generate up to five dimensional data consisting of linear events.</p><p><strong>Arguments</strong></p><ul><li><code>ot=0.0</code>: first sample for the time axis in secs.</li><li><code>dt=0.004</code>: time sampling interval in secs.</li><li><code>nt=500</code>: number of time samples.</li><li><code>ox1=0.0</code>: first sample for the first spatial dimension in meters.</li><li><code>dx1=10.0</code>: sample interval for the first spatial dimension in meters.</li><li><code>nx1=100</code>: number of samples for the first spatial dimension.</li><li><code>ox2=0.0</code>: first sample for the second spatial dimension in meters.</li><li><code>dx2=10.0</code>: sample interval for the second spatial dimension in meters.</li><li><code>nx2=1</code>: number of samples for the second spatial dimension.</li><li><code>ox3=0.0</code>: second sample for the third spatial dimension in meters.</li><li><code>dx3=10.0</code>: sample interval for the third spatial dimension in meters.</li><li><code>nx3=1</code>: number of samples for the third spatial dimension.</li><li><code>ox4=0.0</code>: third sample for the fourth spatial dimension in meters.</li><li><code>dx4=10.0</code>: sample interval for the fourth spatial dimension in meters.</li><li><code>nx4=1</code>:number of samples for the fourth spatial dimension.</li><li><code>tau=[1.0, 1.5]</code>: intercept traveltimes for each event.</li><li><code>p1=[0.0001,-0.0003]</code>: Dip of events on the first dimension</li><li><code>p2,p3,p4=[0, 0]</code>: Dip of events on the following dimensions</li><li><code>amp=[1.0,-1.0]</code>: amplitudes for each linear event.</li><li><code>f0=20.0</code>: central frequency of wavelet for each linear event.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using SeisPlot
julia&gt; d = SeisLinearEvents(); SeisPlotTX(d);</code></pre><p>Credits: Aaron Stanton, 2015</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Modelling/SeisLinearEvents.jl#L1-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisParabEvents" href="#SeisProcessing.SeisParabEvents"><code>SeisProcessing.SeisParabEvents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisParabEvents(; &lt;keyword arguments&gt;)</code></pre><p>Generate up to five dimensional data consisting of parabolic events.</p><p><strong>Arguments</strong></p><ul><li><code>ot=0.0</code>: first sample for the time axis in secs.</li><li><code>dt=0.004</code>: time sampling interval in secs.</li><li><code>nt=500</code>: number of time samples.</li><li><code>ox1=0.0</code>: first sample for the first spatial dimension in meters.</li><li><code>dx1=10.0</code>: sample interval for the first spatial dimension in meters.</li><li><code>nx1=100</code>: number of samples for the first spatial dimension.</li><li><code>ox2=0.0</code>: first sample for the second spatial dimension in meters.</li><li><code>dx2=10.0</code>: sample interval for the second spatial dimension in meters.</li><li><code>nx2=1</code>: number of samples for the second spatial dimension.</li><li><code>ox3=0.0</code>: second sample for the third spatial dimension in meters.</li><li><code>dx3=10.0</code>: sample interval for the third spatial dimension in meters.</li><li><code>nx3=1</code>: number of samples for the third spatial dimension.</li><li><code>ox4=0.0</code>: third sample for the fourth spatial dimension in meters.</li><li><code>dx4=10.0</code>: sample interval for the fourth spatial dimension in meters.</li><li><code>nx4=1</code>:number of samples for the fourth spatial dimension.</li><li><code>tau=[1.0, 1.6]</code>: intercept traveltimes for each event.</li><li>`p1=[0.0000,-0.0001]</li><li>`p2=[0.0003, 0.0002]</li><li>`p3=[-0.0001,-0.0001]</li><li>`p4=[0.0001,-0.0000]</li><li><code>amp=[1.0,-1.0]</code>: amplitudes for each parabolic event.</li><li><code>wavelet=&quot;ricker&quot;</code>: wavelet used to model the parabolicr events.</li><li><code>f0=[20.0]</code>: central frequency of wavelet for each parabolic event.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using SeisPlot
julia&gt; d = SeisParabEvents(); SeisPlotTX(d);</code></pre><p>Credits: Mauricio D Sacchi, 2015</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Modelling/SeisParabEvents.jl#L1-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisHypEvents" href="#SeisProcessing.SeisHypEvents"><code>SeisProcessing.SeisHypEvents</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>SeisHypEvents(; &lt;keyword arguments&gt;)</p><p>Generate two dimensional data consisting of hyperbolic events.</p><p><strong>Arguments</strong></p><ul><li><code>ot::Real=0.0</code>: first sample for the time axis in secs.</li><li><code>dt::Real=0.004</code>: time sampling interval in secs.</li><li><code>nt::Int=301</code>: number of time samples.</li><li><code>ox::Real=-1000.0</code>: first sample for spatial dimension in meters.</li><li><code>dx::Real=20.0</code>: sample interval for the spatial dimension in meters.</li><li><code>nx::Int=101</code>: number of samples for the spatial dimension.</li><li><code>tau::Vector{Real}=[0.2, 0.6, 0.9]</code>: intercept traveltimes for each event.</li><li><code>vel::Vector{Real}=[1500.0, 2000.0, 3000.0]</code>: rms velocities in m/s</li><li><code>apex::Vector{Real}=[0.0, 0.0, 0.0]</code>: apex-shifts in meters.</li><li><code>amp::Vector{Real}=[1.0, -1.0, 1.0]</code>: amplitudes for each event.</li><li><code>wavelet::AbstractString=&quot;ricker&quot;</code>: wavelet used to model the events.</li><li><code>f0::Vector{Real}=[20.0]</code>: central frequency of wavelet for each event.</li></ul><p><strong>Output</strong></p><ul><li><code>d::Array{Real, 2}</code>: two dimensional data consisting of hyperbolic events.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using SeisPlot
julia&gt; d = SeisHypEvents(); SeisPlotTX(d);
julia&gt; d = SeisHypEvents(apex=[100, 200, -300], f0=[30, 20, 15]);
SeisPlotTX(d);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Modelling/SeisHypEvents.jl#L1-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisKolmogoroff" href="#SeisProcessing.SeisKolmogoroff"><code>SeisProcessing.SeisKolmogoroff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisKolmogoroff(in)</code></pre><p>Transform a wavelet into its minimum phase equivalent.</p><p><strong>Arguments</strong></p><ul><li><code>in::Array{Real,1}</code>: input wavelet.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using PyPlot
julia&gt; w = Ricker()
julia&gt; wmin = SeisKolmogoroff(w)
julia&gt; plot(w); plot(wmin)</code></pre><p><strong>Reference</strong></p><ul><li>Claerbout, Jon F., 1976, Fundamentals of geophysical data processing.</li></ul><p>McGraw-Hill Inc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisKolmogoroff.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.MeasureSNR" href="#SeisProcessing.MeasureSNR"><code>SeisProcessing.MeasureSNR</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">MeasureSNR(signal, noisy; db=false)</code></pre><p>Measure the signal-to-noise ratio between the clean input <code>signal</code> and the contaminated input <code>noisy</code>.</p><p><strong>Arguments</strong></p><ul><li><code>signal::Array{Real, N}</code>: N-dimensional clean signal. <code>N</code> must be &lt;= 5.</li><li><code>noisy::Array{Real, N}</code>: N-dimensional noisy signal of same size as <code>signal</code>.</li><li><code>db::Bool=false</code>: Flag is false if the signal-to-noise ratio is measured by amplitude. Flag is true if snr is in dB.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; d = SeisHypEvents(); dnoisy = SeisAddNoise(d, 2);
MeasureSNR(d, dnoisy)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Tools/MeasureSNR.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisBandPass" href="#SeisProcessing.SeisBandPass"><code>SeisProcessing.SeisBandPass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisBandPass(in; &lt;keyword arguments&gt;)</code></pre><p>Apply a bandpass filter to seismic data. Input and output data is 2D in tx domain. Filter is applied in fx domain.</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: Input 2D data array in tx domain. Time is first dimension.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>dt=0.004</code>: time sampling interval in secs.</li><li><code>fa=0</code>: lower frequency cut [Hz]</li><li><code>fb=0</code>: lower frequency banpass [Hz]</li><li><code>fc=60</code>: upper frequency bandpass [Hz]</li><li><code>fd=80</code>: upper frequency cut [Hz]</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; d = SeisLinearEvents(); SeisPlotAmplitude(d,125,0.004);
julia&gt; d_filter = SeisBandPass(d;dt=0.004,fa=2,fb=8,fc=12,fd=20); SeisPlotAmplitude(d_filter,125,0.004)
julia&gt; SeisPlot([d d_filter],title=&quot;Data and Filtered data&quot;)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisBandPass.jl#L1-L24">source</a><div><div><pre><code class="language-none">SeisBandPass(in,out,parameters; &lt;keyword arguments&gt;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>in::String</code>: Input file - Seis format</li><li><code>out::String</code>: Output file - Seis format.</li><li><code>parameters</code> : list of the keyword arguments for the function SeisBandPass.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial trace number</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; param = Dict(:fa&gt;=0,:fb=&gt;0,:fc=&gt;60,:fd=&gt;80)
julia&gt; SeisBandPass(filein,fileout, param,group=&quot;all&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisBandPass.jl#L73-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisDecimate" href="#SeisProcessing.SeisDecimate"><code>SeisProcessing.SeisDecimate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisDecimate(in; &lt;keyword arguments&gt;)</code></pre><p>Apply random or regular decimation to a multidimensional array of data. Input and output have the same dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: input data as 2D, or 3D,4D,5D tensors. The first dimension is time.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>mode=&quot;random&quot;</code>: decimation mode. Random is default, else decimates uniformly.</li><li><code>perc=50</code>: percentage of traces equal to zero (decimated). Only for random mode</li><li><code>incx1=1</code>: consecutive traces zeroed in first dimension. Only for regular decimation</li><li><code>incx2=1</code>: consecutive traces zeroed in second dimension.</li><li><code>incx3=1</code>: consecutive traces zeroed in third dimension.</li><li><code>incx4=1</code>: consecutive traces zeroed in fourth dimension.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; d = SeisLinearEvents(); deci = SeisDecimate(d);</code></pre><p><em>Credits: Aaron Stanton,2017</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisDecimate.jl#L1-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisDelay" href="#SeisProcessing.SeisDelay"><code>SeisProcessing.SeisDelay</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisDelay(in; &lt;keyword arguments&gt;)</code></pre><p>Apply a time delay to 2D data</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: input 2D data array in tx domain. First dimension is time.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>delay=0.1</code>: desired time delay in secs.</li><li><code>dt=0.004</code>: time sampling interval in secs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; d = SeisLinearEvents(); deli = SeisDelay(d);</code></pre><p><em>Credits: Aaron Stanton,2017</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisDelay.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisDiff" href="#SeisProcessing.SeisDiff"><code>SeisProcessing.SeisDiff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisDiff(d ; &lt;keyword arguments&gt;)</code></pre><p>Apply differentiation to seismic traces in freq. It can also be used to apply a phase rotation</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: Input 2D data array in tx domain. First dimension is time.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>delay=0.1</code>: desired time delay in seconds.</li><li><code>pow=-2</code>: order of derivative</li><li><code>rot=0</code>: constant phase shift or rotation</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; d = SeisLinearEvents(); SeisPlotTX(d);
julia&gt; d2 = SeisDiff(d;dt=0.004,pow=1); SeisPlotTX(d);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisDiff.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisEnvelope" href="#SeisProcessing.SeisEnvelope"><code>SeisProcessing.SeisEnvelope</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisEnvelope(in; &lt;keyword arguments&gt;)</code></pre><p>Calculate the envelope attribute of a group of input traces.</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: input data. A 2D Array where the first dimension is time.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using PyPlot
julia&gt; dtsec = 0.002; w = Ricker(dt=dtsec);
julia&gt; e = SeisEnvelope(w); t=dtsec*collect(0:1:length(w)-1);plot(t,w,t,e,&quot;-r&quot;);xlabel(&quot;Time [s]&quot;)</code></pre><p><em>Credits: Aaron Stanton,2017</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisEnvelope.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisFKFilter" href="#SeisProcessing.SeisFKFilter"><code>SeisProcessing.SeisFKFilter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisFKFilter(in; &lt;keyword arguments&gt;)</code></pre><p>Removes energy from seismic data by applying filters to a gather in the FK domain</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: 2D input data in TX domain. First dimension is time.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>dt=0.004</code>: time sampling interval in secs.</li><li><code>dx=10</code>: space sampling interval in meters.</li><li><code>va=-2000,vb=-3000,vc=3000,vd=2000</code>: apparent velocity corners to filter</li></ul><p><strong>Output</strong></p><ul><li><code>out</code>: Filtered data in TX domain</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; d = SeisLinearEvents(); df = SeisFKFilter(d,va=-4000,vb=-6000,vc=6000,vd=4000);</code></pre><p><em>Credits: Aaron Stanton,2017</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisFKFilter.jl#L1-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisGain" href="#SeisProcessing.SeisGain"><code>SeisProcessing.SeisGain</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisGain(d ; &lt;keyword arguments&gt;)</code></pre><p>Gain a group of traces. Input and output are 2D.</p><p><strong>Arguments</strong></p><ul><li><code>d::Array{Real,2}</code>: two dimensional data.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>dt::Real=0.004</code>: sampling interval in secs.</li><li><code>kind::AbstractString=&quot;time&quot;</code>: if kind=&quot;time&quot;, gain = t.^a . * exp(-bt);                        if kind=&quot;agc&quot;, automatic gain control is applied.</li><li><code>coef::Vector{Real}=[2.0,0.0]</code>: if kind=&quot;time&quot;, coef = [a,b];                                  if kind=&quot;agc&quot;, coef = [agc_gate]</li><li><code>normal::Int=0</code>: <code>normal=0</code> no normalization; <code>normal=1</code> normalize each trace by                 amplitude; <code>normal=2</code> normalize each trace by rms value/</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; using PyPlot
julia&gt; d = SeisHypEvents();
       dout = SeisGain(d, kind=&quot;agc&quot;, coef=[0.05]);
       SeisPlotTX([d dout]);</code></pre><p>Credits:  Aaron Staton Updates: Juan I. Sabbione, Mauricio D. Sacchi, Fernanda Carozzi</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisGain.jl#L1-L30">source</a><div><div><pre><code class="language-none">SeisGain(in,out,parameters; &lt;keyword arguments&gt;)

Gain a group of traces. Input and output are file names.</code></pre><p><strong>Arguments</strong></p><ul><li><code>in::String</code>: Input file - Seis format</li><li><code>out::String</code>: Output file - Seis format.</li><li><code>parameters</code> : list of the keyword arguments for the function SeisGain.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial trace number</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; param = Dict(:dt=&gt;0.01,:kind=&gt;&quot;time&quot;,:coef=&gt;[2.0,0.0],:normal=&gt;0)
julia&gt; SeisGain(filein,fileout, param,group=&quot;all&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisGain.jl#L96-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisMute" href="#SeisProcessing.SeisMute"><code>SeisProcessing.SeisMute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisMute(d; &lt;keyword arguments&gt;) -&gt; Array{Real,2}</code></pre><p>Mute trace noise before the first arrival. The muting function depends on the offset between source and receiver and the velocity of the first layer as t<em>mute = t</em>0 + offset/v1.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: Array of input traces.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>offset=[0.]</code>: Vector of distances between source and receiver.</li><li><code>tmute=0.</code>: initial muting time</li><li><code>vmute=1500.</code>: Velocity of the first layer.</li><li><code>taper=0.1</code>: Taper of the muting function</li><li><code>dt::Real=0.004</code>: sampling interval in secs.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisMute.jl#L1-L19">source</a><div><div><pre><code class="language-none">SeisMute(in,out,parameters; &lt;keyword arguments&gt;)</code></pre><p>Mutes noise before first arrival of traces in a file. Saves the muted traces to an output file. The muting function depends on the offset between source and receiver and the velocity of the first layer as t<em>mute = t</em>0 + offset/v1.</p><p><strong>Arguments</strong></p><ul><li><code>in::String</code>: Input file - Seis format.</li><li><code>out::String</code>: Output file - Seis format.</li><li><code>parameters</code> : list of the keyword arguments for the function SeisMute.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial trace number</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; param = Dict(:tmute=&gt;0.0, :vmute=&gt;10000, :taper=&gt;0.05,:dt=&gt;0.01)
julia&gt; SeisMute(filein,fileout, param,group=&quot;some&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisMute.jl#L43-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisNMO" href="#SeisProcessing.SeisNMO"><code>SeisProcessing.SeisNMO</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisNMO(in,out,parameters; &lt;keyword arguments&gt;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>in::String</code>: Input file - Seis format.</li><li><code>out::String</code>: Output file - Seis format.</li><li><code>parameters</code> : list of the keyword arguments for the function SeisMute.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial trace number</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; param = Dict(:tmute=&gt;0.0, :vmute=&gt;10000, :taper=&gt;0.05,:dt=&gt;0.01)
julia&gt; SeisMute(filein,fileout, param,group=&quot;some&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisNMO.jl#L45-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisPWD" href="#SeisProcessing.SeisPWD"><code>SeisProcessing.SeisPWD</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisPWD(in;&lt;keyword arguments&gt;)</code></pre><p>Dip estimation by Plane Wave Destruction. see http://sepwww.stanford.edu/data/media/public/sep//prof/pvi.pdf Chapter 4.</p><p><strong>Arguments</strong></p><p>-<code>w1=10</code> -<code>w2=10</code> -<code>dz_in=1</code> -<code>dx_in=1</code> -<code>format=&quot;angle&quot;</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisPWD.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisProcessFile" href="#SeisProcessing.SeisProcessFile"><code>SeisProcessing.SeisProcessFile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">  SeisProcessFile(in,out,operators,parameters;&lt;keyword arguments&gt;)</code></pre><p>Run processing flows that read and write from disk</p><p>f is a function that has the following syntax: d2 = f(d1,param), where param is list of keyword arguments for the function. Note that f can be a vector of functions. They will be executed sequentially on the same group of traces.</p><p><strong>Arguments</strong></p><ul><li><code>in</code>: input filename of type String or Array{String,1} - Seis format</li><li><code>out</code>: output filenames of type String or Array{String,1} - Seis format</li><li><code>operators</code></li><li><code>parameters</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial traces</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><p>Apply a bandpass filter to a seismic cube sequentially, by shot gather. Assume dt is equal to 0.002.</p><pre><code class="language-none">julia&gt; operators = [SeisBandPass]
julia&gt; param = [Dict(:dt=&gt;0.002, :fa=&gt;20,:fb=&gt;30,:fc=&gt;80,:fd=&gt;90)]
julia&gt; SeisProcessFile(filein,fileout,operators,param,key=[&quot;sx&quot;])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisProcessFile.jl#L1-L32">source</a><div><div><pre><code class="language-none">  SeisProcessFile(in1,in2,out,operators,parameters;&lt;keyword arguments&gt;)</code></pre><p>Run processing flows that read from 2 files and write to disk</p><p><strong>Arguments</strong></p><ul><li><code>in1::String</code>: input filename - Seis format.</li><li><code>in2::String</code>: input filename - Seis format.</li><li><code>out::String</code>: output filename - Seis format.</li><li><code>operators</code></li><li><code>parameters</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>group=&quot;gather&quot;</code> : Options are all, some or gather</li><li><code>key=[&quot;imx&quot;,&quot;imy&quot;]</code> : Defines type of gather</li><li><code>itrace=1</code> : Initial traces</li><li><code>ntrace=10000</code> : Total number of traces to process at once</li></ul><p><strong>Example</strong></p><p>Apply a bandpass filter to a seismic cube sequentially, by shot gather. Assume dt is equal to 0.002.</p><pre><code class="language-none">julia&gt; operators = [SeisBandPass]
julia&gt; param = [Dict(:dt=&gt;0.002, :fa=&gt;20,:fb=&gt;30,:fc=&gt;80,:fd=&gt;90)]
julia&gt; SeisProcessFile(filein,fileout,operators,param,key=[&quot;sx&quot;])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisProcessFile.jl#L85-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisRadonFreqFor" href="#SeisProcessing.SeisRadonFreqFor"><code>SeisProcessing.SeisRadonFreqFor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisRadonFreqFor(in, nt; &lt;keyword arguments&gt;)</code></pre><p>Transform a tau-p gather to a time-offset gather using a frequency domain forward parabolic or linear Radon operator.</p><p><strong>Arguments</strong></p><ul><li><code>in::Array{Float64,2}</code>: 2D Radon panel, <code>in[1:ntau,1:np]</code>, where <code>ntau</code> is the</li></ul><p>number of intercept times and <code>np</code> the number of curvatures or ray parameters.</p><ul><li><code>nt::Int</code>: number of time samples.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>order=&quot;parab&quot;</code>: <code>&quot;parab&quot;</code> for parabolic transform, <code>&quot;linear&quot;</code></li></ul><p>for linear transform.</p><ul><li><code>dt=0.004</code>: time sampling interval in seconds.</li><li><code>h=collect(0.0:20.0:1000.0)</code>: offset vector; <code>h[1:nh]</code>.</li><li><code>href=0.0</code>: reference offset for parabolic Radon Transform. If the</li></ul><p>defautl value <code>href=0.0</code> is given, <code>href</code> is set to <code>max(abs(h))</code>.</p><ul><li><code>p=collect(-0.05:0.01:2.2)</code>: <code>p[1:np]</code>. If <code>order=&quot;parab&quot;</code>, <code>p</code></li></ul><p>is a vector of residual moveout (&quot;curvatures&quot;) at reference offset <code>href</code> in seconds; if <code>order=linear</code>, <code>p</code> is a vector of ray parameters in s/m.</p><ul><li><code>flow=0.0</code>: minimum frequency in the data in Hz.</li><li><code>fhigh=125.0</code>: maximum frequency in the data in Hz.</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>: data synthetized via forward Radon modeling, <code>d[1:nt, 1:nh]</code>.</li></ul><p><strong>References</strong></p><ul><li>Hampson, D., 1986, Inverse velocity stacking for multiple elimination:</li></ul><p>Canadian Journal of Exploration Geophysics, 22, 44-55.</p><ul><li>Sacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and</li></ul><p>offset space reconstruction: Geophysics, 60, 1169-1177.</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisRadonFreqFor.jl#L1-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisRadonFreqInv" href="#SeisProcessing.SeisRadonFreqInv"><code>SeisProcessing.SeisRadonFreqInv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisRadonFreqInv(d; &lt;keyword arguments&gt;)</code></pre><p>Transform a Gather from time-offset gather to tau-p gather using a frequency domain inverse parabolic or linear Radon operator via least-squares inversion.</p><p><strong>Arguments</strong></p><ul><li><code>d::Array{Float64,2}</code>: 2D data, <code>d[1:nt,1:nh]</code>, where <code>nt</code> is number of</li></ul><p>time samples and <code>nh</code> the number of receivers.</p><p><strong>Keyword arguments</strong></p><ul><li><code>order::&quot;parab&quot;</code>: <code>&quot;parab&quot;</code> for parabolic transform, <code>&quot;linear&quot;</code></li></ul><p>for linear transform.</p><ul><li><code>dt=0.004</code>: sampling interval in seconds.</li><li><code>h=collect(0.0:20.0:1000.0)</code>: offset vector <code>h[1:nh]</code>.</li><li><code>href=0.0</code>: reference offset for parabolic Radon Transform. If the</li></ul><p>defautl value <code>href=0.0</code> is given, <code>href</code> is set to <code>max(abs(h))</code>.</p><ul><li><code>p=collect(-0.05:0.01:2.2)</code>: <code>p[1:np]</code>. If <code>order=&quot;parab&quot;</code>, <code>p</code></li></ul><p>is a vector of residual moveout (&quot;curvatures&quot;) at reference offset <code>href</code> in seconds; if <code>order=linear</code>, <code>p</code> is a vector of ray parameters in s/m.</p><ul><li><code>flow=0.0</code>: minimum frequency in the data in Hz.</li><li><code>fhigh=125.0</code>: maximum frequency in the data in Hz.</li><li><code>mu=0.001</code>: trade off parameter or damping for the L.S. inversion.</li></ul><p><strong>Output</strong></p><ul><li><code>m</code>: inverted Radon panel <code>m[1:ntau, 1:np]</code>.</li></ul><p><strong>References</strong></p><ul><li>Hampson, D., 1986, Inverse velocity stacking for multiple elimination:</li></ul><p>Canadian Journal of Exploration Geophysics, 22, 44-55.</p><ul><li>Sacchi, M.D. and Ulrych, T.J., 1995, High-resolution velocity gathers and</li></ul><p>offset space reconstruction: Geophysics, 60, 1169-1177.</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisRadonFreqInv.jl#L1-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SeisProcessing.SeisSincInterp1D" href="#SeisProcessing.SeisSincInterp1D"><code>SeisProcessing.SeisSincInterp1D</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SeisSincInterp1D(d,order)</code></pre><p>Resample seismic traces via 1D sinc interpolation. The time series are sampled every dt secs,  the output corresponds to series with time interval dt/<code>order</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Array{Real,N}</code>: N-dimensional data, first dimension is time</li><li><code>order::Integer</code>: order of interpolation 2,4</li></ul><p><strong>Examples</strong></p><p>2-time upsampling of a wavelet</p><pre><code class="language-julia">julia&gt; order = 2; dt=0.004; w = Ricker(dt=dt, f0=20); t = collect(0:1:length(w)-1)*dt;
julia&gt; wout = SeisSincInterp1D(w,order); tout = collect(0:1:length(wout)-1)*dt/order;
julia&gt; plot(t,w); plot(tout,wout,&quot;*&quot;)</code></pre><p>4-time upsampling of a gather</p><pre><code class="language-julia">julia&gt; d = SeisLinearEvents(); di = SeisSincInterp1D(d,4);
julia&gt;  SeisPlotTX(d,style=&quot;wiggles&quot;)
julia&gt;  SeisPlotTX(di,style=&quot;wiggles&quot;)  </code></pre><p>MAY 2018, MDS</p></div></div><a class="source-link" target="_blank" href="https://github.com/SeismicJulia/SeisProcessing.jl/blob/31c9f48933caeaa4a33bf9ad5835cae9fafd870c/src/Processing/SeisSincInterp1D.jl#L1-L25">source</a></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
